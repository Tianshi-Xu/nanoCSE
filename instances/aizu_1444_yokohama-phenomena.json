{
    "id": "1444",
    "title": "Yokohama Phenomena",
    "title_slug": "yokohama-phenomena",
    "description": "Yokohama Phenomena\n\nDo you know about Yokohama Phenomena? The phenomenon takes place when three programmers, sitting around a table, hold a single pen together above a board. A grid of squares is drawn on the board, with each square marked with a single letter. Although none of the participants purposely moves the pen, its nib, as if it has a will, goes down to one of the squares marked with Y, and then starts moving on the board. The squares passed are marked with O, K, O, H, A, and M in this order, and then the nib stops on the square marked with A.\n\nLet us call the series of squares along such a trajectory of the nib a YOKOHAMA trace. A YOKOHAMA trace is defined as follows.\n\nIt is a series of eight squares in the given grid of squares.\nEvery square in the series, except for the first one, shares an edge with (is edge-adjacent to) its directly preceding square in the series.\nThe letters marked in the eight squares of the series are Y, O, K, O, H, A, M, and A, in this order.\n\nNote that the same square may appear more than once in the series.\n\nFigure A.1 (a) is an illustration of the board corresponding to Sample Input 1. Figures A.1 (b) and (c) show trajectories on two of the YOKOHAMA traces. Both traces start at the leftmost square in the upper row. The same square marked with O appears twice in the trace illustrated in Figure A.1 (c).\n\n\n\nFigure A.1. A board and trajectories on two of the YOKOHAMA traces\n\n\n\nYou are given a grid of squares, each marked with one of six letters, A, H, K, M, O, or Y. Your task is to count how many distinct YOKOHAMA traces are possible on it.\n\nInput\n\nThe input consists of a single test case of the following format.\n\n$n$ $m$\n$x_{1,1}$ ... $x_{1,m}$\n.\n.\n.\n$x_{n,1}$ ... $x_{n,m}$\n\n\nThe first two integers $n$ and $m$ ($1 \\leq n \\leq 10, 1 \\leq m \\leq 10$) describe the size of the grid. The grid has squares arranged in an $n \\times m$ matrix. The following n lines describe the letters marked in the squares. The square at the $i$-th row and the $j$-th column in the grid ($1 \\leq i \\leq n, 1 \\leq j \\leq m$) has letter $x_{i,j}$ marked in it. Each $x_{i,j}$ is one of the six letters, A, H, K, M, O, or Y.\n\nOutput\n\nOutput a line containing the number of distinct YOKOHAMA traces.\n\nSample Input 1\n2 4\nYOHA\nOKAM\n\nSample Output 1\n8\n\nSample Input 2\n3 4\nYOKH\nOKHA\nKHAM\n\nSample Output 2\n0\n\nSample Input 3\n3 6\nMAYOHA\nAHOKAM\nMAYOHA\n\nSample Output 3\n80\n",
    "description_md": "Yokohama Phenomena\n\nDo you know about Yokohama Phenomena? The phenomenon takes place when three programmers, sitting around a table, hold a single pen together above a board. A grid of squares is drawn on the board, with each square marked with a single letter. Although none of the participants purposely moves the pen, its nib, as if it has a will, goes down to one of the squares marked with Y, and then starts moving on the board. The squares passed are marked with O, K, O, H, A, and M in this order, and then the nib stops on the square marked with A.\n\nLet us call the series of squares along such a trajectory of the nib a YOKOHAMA trace. A YOKOHAMA trace is defined as follows.\n\nIt is a series of eight squares in the given grid of squares.\nEvery square in the series, except for the first one, shares an edge with (is edge-adjacent to) its directly preceding square in the series.\nThe letters marked in the eight squares of the series are Y, O, K, O, H, A, M, and A, in this order.\n\nNote that the same square may appear more than once in the series.\n\nFigure A.1 (a) is an illustration of the board corresponding to Sample Input 1. Figures A.1 (b) and (c) show trajectories on two of the YOKOHAMA traces. Both traces start at the leftmost square in the upper row. The same square marked with O appears twice in the trace illustrated in Figure A.1 (c).\n\n\n\nFigure A.1. A board and trajectories on two of the YOKOHAMA traces\n\n\n\nYou are given a grid of squares, each marked with one of six letters, A, H, K, M, O, or Y. Your task is to count how many distinct YOKOHAMA traces are possible on it.\n\nInput\n\nThe input consists of a single test case of the following format.\n\n$n$ $m$\n$x_{1,1}$ ... $x_{1,m}$\n.\n.\n.\n$x_{n,1}$ ... $x_{n,m}$\n\n\nThe first two integers $n$ and $m$ ($1 \\leq n \\leq 10, 1 \\leq m \\leq 10$) describe the size of the grid. The grid has squares arranged in an $n \\times m$ matrix. The following n lines describe the letters marked in the squares. The square at the $i$-th row and the $j$-th column in the grid ($1 \\leq i \\leq n, 1 \\leq j \\leq m$) has letter $x_{i,j}$ marked in it. Each $x_{i,j}$ is one of the six letters, A, H, K, M, O, or Y.\n\nOutput\n\nOutput a line containing the number of distinct YOKOHAMA traces.\n\nSample Input 1\n2 4\nYOHA\nOKAM\n\nSample Output 1\n8\n\nSample Input 2\n3 4\nYOKH\nOKHA\nKHAM\n\nSample Output 2\n0\n\nSample Input 3\n3 6\nMAYOHA\nAHOKAM\nMAYOHA\n\nSample Output 3\n80\n",
    "difficulty": "",
    "tags": [],
    "source": "aizu",
    "url": "https://onlinejudge.u-aizu.ac.jp/challenges/sources/ICPC/Regional/1444?year=2023",
    "type": "io",
    "release_timestamp": null,
    "release_date": null,
    "time_limit_nanos": 2000000000,
    "memory_limit_bytes": 2097152000,
    "starter_code": null,
    "solutions": {
        "cpp": {
            "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint n, m;\nvector<string> grid;\nstring target = \"YOKOHAMA\";\nint target_len = 8;\nint directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nbool isValid(int x, int y) {\n    return x >= 0 && x < n && y >= 0 && y < m;\n}\n\nint dfs(int x, int y, int index) {\n    if (index == target_len - 1) return 1;\n\n    int count = 0;\n    for (int i = 0; i < 4; ++i) {\n        int nx = x + directions[i][0];\n        int ny = y + directions[i][1];\n        if (isValid(nx, ny) && grid[nx][ny] == target[index + 1]) {\n            count += dfs(nx, ny, index + 1);\n        }\n    }\n    return count;\n}\n\nint countYokohamaTraces() {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == 'Y') {\n                count += dfs(i, j, 0);\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    cin >> n >> m;\n    grid.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> grid[i];\n    }\n\n    int result = countYokohamaTraces();\n    cout << result << endl;\n\n    return 0;\n}",
            "memory": 3,
            "memoryDistribution": "[[3, 0, \"#include <iostream>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nint n, m;\\nvector<string> grid;\\nstring target = \\\"YOKOHAMA\\\";\\nint target_len = 8;\\nint directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\nbool isValid(int x, int y) {\\n    return x >= 0 && x < n && y >= 0 && y < m;\\n}\\n\\nint dfs(int x, int y, int index) {\\n    if (index == target_len - 1) return 1;\\n\\n    int count = 0;\\n    for (int i = 0; i < 4; ++i) {\\n        int nx = x + directions[i][0];\\n        int ny = y + directions[i][1];\\n        if (isValid(nx, ny) && grid[nx][ny] == target[index + 1]) {\\n            count += dfs(nx, ny, index + 1);\\n        }\\n    }\\n    return count;\\n}\\n\\nint countYokohamaTraces() {\\n    int count = 0;\\n    for (int i = 0; i < n; ++i) {\\n        for (int j = 0; j < m; ++j) {\\n            if (grid[i][j] == 'Y') {\\n                count += dfs(i, j, 0);\\n            }\\n        }\\n    }\\n    return count;\\n}\\n\\nint main() {\\n    cin >> n >> m;\\n    grid.resize(n);\\n    for (int i = 0; i < n; ++i) {\\n        cin >> grid[i];\\n    }\\n\\n    int result = countYokohamaTraces();\\n    cout << result << endl;\\n\\n    return 0;\\n}\"]]",
            "runtime": 0,
            "runtimeDistribution": "[[0, 0, \"#include <iostream>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nint n, m;\\nvector<string> grid;\\nstring target = \\\"YOKOHAMA\\\";\\nint target_len = 8;\\nint directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\nbool isValid(int x, int y) {\\n    return x >= 0 && x < n && y >= 0 && y < m;\\n}\\n\\nint dfs(int x, int y, int index) {\\n    if (index == target_len - 1) return 1;\\n\\n    int count = 0;\\n    for (int i = 0; i < 4; ++i) {\\n        int nx = x + directions[i][0];\\n        int ny = y + directions[i][1];\\n        if (isValid(nx, ny) && grid[nx][ny] == target[index + 1]) {\\n            count += dfs(nx, ny, index + 1);\\n        }\\n    }\\n    return count;\\n}\\n\\nint countYokohamaTraces() {\\n    int count = 0;\\n    for (int i = 0; i < n; ++i) {\\n        for (int j = 0; j < m; ++j) {\\n            if (grid[i][j] == 'Y') {\\n                count += dfs(i, j, 0);\\n            }\\n        }\\n    }\\n    return count;\\n}\\n\\nint main() {\\n    cin >> n >> m;\\n    grid.resize(n);\\n    for (int i = 0; i < n; ++i) {\\n        cin >> grid[i];\\n    }\\n\\n    int result = countYokohamaTraces();\\n    cout << result << endl;\\n\\n    return 0;\\n}\"]]"
        },
        "golang": {
            "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tscanner.Scan()\n\tvar n, m int\n\tfmt.Sscanf(scanner.Text(), \"%d %d\", &n, &m)\n\n\tgrid := make([]string, n)\n\tfor i := 0; i < n; i++ {\n\t\tscanner.Scan()\n\t\tgrid[i] = scanner.Text()\n\t}\n\n\tsequence := []byte{'Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'}\n\n\tvar dfs func(i, j, k int) int\n\tdfs = func(i, j, k int) int {\n\t\tif k == 7 {\n\t\t\treturn 1\n\t\t}\n\t\tres := 0\n\t\tdirections := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n\t\tfor _, dir := range directions {\n\t\t\tni, nj := i+dir[0], j+dir[1]\n\t\t\tif ni >= 0 && ni < n && nj >= 0 && nj < m {\n\t\t\t\tif grid[ni][nj] == sequence[k+1] {\n\t\t\t\t\tres += dfs(ni, nj, k+1)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tans := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := 0; j < m; j++ {\n\t\t\tif grid[i][j] == sequence[0] {\n\t\t\t\tans += dfs(i, j, 0)\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Println(ans)\n}",
            "memory": 8,
            "memoryDistribution": "[[8, 0, \"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tvar n, m int\\n\\tfmt.Sscanf(scanner.Text(), \\\"%d %d\\\", &n, &m)\\n\\n\\tgrid := make([]string, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tgrid[i] = scanner.Text()\\n\\t}\\n\\n\\tsequence := []byte{'Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'}\\n\\n\\tvar dfs func(i, j, k int) int\\n\\tdfs = func(i, j, k int) int {\\n\\t\\tif k == 7 {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\t\\tres := 0\\n\\t\\tdirections := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\\n\\t\\tfor _, dir := range directions {\\n\\t\\t\\tni, nj := i+dir[0], j+dir[1]\\n\\t\\t\\tif ni >= 0 && ni < n && nj >= 0 && nj < m {\\n\\t\\t\\t\\tif grid[ni][nj] == sequence[k+1] {\\n\\t\\t\\t\\t\\tres += dfs(ni, nj, k+1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\tans := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif grid[i][j] == sequence[0] {\\n\\t\\t\\t\\tans += dfs(i, j, 0)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfmt.Println(ans)\\n}\"], [8, 0, \"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tvar n, m int\\n\\tfmt.Sscanf(scanner.Text(), \\\"%d %d\\\", &n, &m)\\n\\n\\tgrid := make([]string, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tgrid[i] = scanner.Text()\\n\\t}\\n\\n\\tsequence := []byte{'Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'}\\n\\n\\tvar dfs func(i, j, k int) int\\n\\tdfs = func(i, j, k int) int {\\n\\t\\tif k == 7 {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\t\\tres := 0\\n\\t\\tdirections := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\\n\\t\\tfor _, dir := range directions {\\n\\t\\t\\tni, nj := i+dir[0], j+dir[1]\\n\\t\\t\\tif ni >= 0 && ni < n && nj >= 0 && nj < m {\\n\\t\\t\\t\\tif grid[ni][nj] == sequence[k+1] {\\n\\t\\t\\t\\t\\tres += dfs(ni, nj, k+1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\tans := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif grid[i][j] == sequence[0] {\\n\\t\\t\\t\\tans += dfs(i, j, 0)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfmt.Println(ans)\\n}\"], [8, 0, \"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tvar n, m int\\n\\tfmt.Sscanf(scanner.Text(), \\\"%d %d\\\", &n, &m)\\n\\n\\tgrid := make([]string, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tgrid[i] = scanner.Text()\\n\\t}\\n\\n\\tsequence := []byte{'Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'}\\n\\n\\tvar dfs func(i, j, k int) int\\n\\tdfs = func(i, j, k int) int {\\n\\t\\tif k == 7 {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\t\\tres := 0\\n\\t\\tdirections := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\\n\\t\\tfor _, dir := range directions {\\n\\t\\t\\tni, nj := i+dir[0], j+dir[1]\\n\\t\\t\\tif ni >= 0 && ni < n && nj >= 0 && nj < m {\\n\\t\\t\\t\\tif grid[ni][nj] == sequence[k+1] {\\n\\t\\t\\t\\t\\tres += dfs(ni, nj, k+1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\tans := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif grid[i][j] == sequence[0] {\\n\\t\\t\\t\\tans += dfs(i, j, 0)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfmt.Println(ans)\\n}\"], [8, 0, \"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tvar n, m int\\n\\tfmt.Sscanf(scanner.Text(), \\\"%d %d\\\", &n, &m)\\n\\n\\tgrid := make([]string, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tgrid[i] = scanner.Text()\\n\\t}\\n\\n\\tsequence := []byte{'Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'}\\n\\n\\tvar dfs func(i, j, k int) int\\n\\tdfs = func(i, j, k int) int {\\n\\t\\tif k == 7 {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\t\\tres := 0\\n\\t\\tdirections := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\\n\\t\\tfor _, dir := range directions {\\n\\t\\t\\tni, nj := i+dir[0], j+dir[1]\\n\\t\\t\\tif ni >= 0 && ni < n && nj >= 0 && nj < m {\\n\\t\\t\\t\\tif grid[ni][nj] == sequence[k+1] {\\n\\t\\t\\t\\t\\tres += dfs(ni, nj, k+1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\tans := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif grid[i][j] == sequence[0] {\\n\\t\\t\\t\\tans += dfs(i, j, 0)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfmt.Println(ans)\\n}\"], [8, 0, \"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tvar n, m int\\n\\tfmt.Sscanf(scanner.Text(), \\\"%d %d\\\", &n, &m)\\n\\n\\tgrid := make([]string, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tgrid[i] = scanner.Text()\\n\\t}\\n\\n\\tsequence := []byte{'Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'}\\n\\n\\tvar dfs func(i, j, k int) int\\n\\tdfs = func(i, j, k int) int {\\n\\t\\tif k == 7 {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\t\\tres := 0\\n\\t\\tdirections := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\\n\\t\\tfor _, dir := range directions {\\n\\t\\t\\tni, nj := i+dir[0], j+dir[1]\\n\\t\\t\\tif ni >= 0 && ni < n && nj >= 0 && nj < m {\\n\\t\\t\\t\\tif grid[ni][nj] == sequence[k+1] {\\n\\t\\t\\t\\t\\tres += dfs(ni, nj, k+1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\tans := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif grid[i][j] == sequence[0] {\\n\\t\\t\\t\\tans += dfs(i, j, 0)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfmt.Println(ans)\\n}\"]]",
            "runtime": 0,
            "runtimeDistribution": "[[0, 0, \"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tvar n, m int\\n\\tfmt.Sscanf(scanner.Text(), \\\"%d %d\\\", &n, &m)\\n\\n\\tgrid := make([]string, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tgrid[i] = scanner.Text()\\n\\t}\\n\\n\\tsequence := []byte{'Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'}\\n\\n\\tvar dfs func(i, j, k int) int\\n\\tdfs = func(i, j, k int) int {\\n\\t\\tif k == 7 {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\t\\tres := 0\\n\\t\\tdirections := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\\n\\t\\tfor _, dir := range directions {\\n\\t\\t\\tni, nj := i+dir[0], j+dir[1]\\n\\t\\t\\tif ni >= 0 && ni < n && nj >= 0 && nj < m {\\n\\t\\t\\t\\tif grid[ni][nj] == sequence[k+1] {\\n\\t\\t\\t\\t\\tres += dfs(ni, nj, k+1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\tans := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif grid[i][j] == sequence[0] {\\n\\t\\t\\t\\tans += dfs(i, j, 0)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfmt.Println(ans)\\n}\"], [0, 0, \"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tvar n, m int\\n\\tfmt.Sscanf(scanner.Text(), \\\"%d %d\\\", &n, &m)\\n\\n\\tgrid := make([]string, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tgrid[i] = scanner.Text()\\n\\t}\\n\\n\\tsequence := []byte{'Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'}\\n\\n\\tvar dfs func(i, j, k int) int\\n\\tdfs = func(i, j, k int) int {\\n\\t\\tif k == 7 {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\t\\tres := 0\\n\\t\\tdirections := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\\n\\t\\tfor _, dir := range directions {\\n\\t\\t\\tni, nj := i+dir[0], j+dir[1]\\n\\t\\t\\tif ni >= 0 && ni < n && nj >= 0 && nj < m {\\n\\t\\t\\t\\tif grid[ni][nj] == sequence[k+1] {\\n\\t\\t\\t\\t\\tres += dfs(ni, nj, k+1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\tans := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif grid[i][j] == sequence[0] {\\n\\t\\t\\t\\tans += dfs(i, j, 0)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfmt.Println(ans)\\n}\"], [0, 0, \"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tvar n, m int\\n\\tfmt.Sscanf(scanner.Text(), \\\"%d %d\\\", &n, &m)\\n\\n\\tgrid := make([]string, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tgrid[i] = scanner.Text()\\n\\t}\\n\\n\\tsequence := []byte{'Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'}\\n\\n\\tvar dfs func(i, j, k int) int\\n\\tdfs = func(i, j, k int) int {\\n\\t\\tif k == 7 {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\t\\tres := 0\\n\\t\\tdirections := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\\n\\t\\tfor _, dir := range directions {\\n\\t\\t\\tni, nj := i+dir[0], j+dir[1]\\n\\t\\t\\tif ni >= 0 && ni < n && nj >= 0 && nj < m {\\n\\t\\t\\t\\tif grid[ni][nj] == sequence[k+1] {\\n\\t\\t\\t\\t\\tres += dfs(ni, nj, k+1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\tans := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif grid[i][j] == sequence[0] {\\n\\t\\t\\t\\tans += dfs(i, j, 0)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfmt.Println(ans)\\n}\"], [0, 0, \"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tvar n, m int\\n\\tfmt.Sscanf(scanner.Text(), \\\"%d %d\\\", &n, &m)\\n\\n\\tgrid := make([]string, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tgrid[i] = scanner.Text()\\n\\t}\\n\\n\\tsequence := []byte{'Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'}\\n\\n\\tvar dfs func(i, j, k int) int\\n\\tdfs = func(i, j, k int) int {\\n\\t\\tif k == 7 {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\t\\tres := 0\\n\\t\\tdirections := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\\n\\t\\tfor _, dir := range directions {\\n\\t\\t\\tni, nj := i+dir[0], j+dir[1]\\n\\t\\t\\tif ni >= 0 && ni < n && nj >= 0 && nj < m {\\n\\t\\t\\t\\tif grid[ni][nj] == sequence[k+1] {\\n\\t\\t\\t\\t\\tres += dfs(ni, nj, k+1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\tans := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif grid[i][j] == sequence[0] {\\n\\t\\t\\t\\tans += dfs(i, j, 0)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfmt.Println(ans)\\n}\"], [0, 0, \"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tvar n, m int\\n\\tfmt.Sscanf(scanner.Text(), \\\"%d %d\\\", &n, &m)\\n\\n\\tgrid := make([]string, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tgrid[i] = scanner.Text()\\n\\t}\\n\\n\\tsequence := []byte{'Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'}\\n\\n\\tvar dfs func(i, j, k int) int\\n\\tdfs = func(i, j, k int) int {\\n\\t\\tif k == 7 {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\t\\tres := 0\\n\\t\\tdirections := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\\n\\t\\tfor _, dir := range directions {\\n\\t\\t\\tni, nj := i+dir[0], j+dir[1]\\n\\t\\t\\tif ni >= 0 && ni < n && nj >= 0 && nj < m {\\n\\t\\t\\t\\tif grid[ni][nj] == sequence[k+1] {\\n\\t\\t\\t\\t\\tres += dfs(ni, nj, k+1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\tans := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif grid[i][j] == sequence[0] {\\n\\t\\t\\t\\tans += dfs(i, j, 0)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfmt.Println(ans)\\n}\"]]"
        },
        "java": {
            "code": "import java.util.*;\n\npublic class Main {\n    static int n, m;\n    static char[][] grid;\n    static final String sequence = \"YOKOHAMA\";\n    static int[] dx = {-1, 1, 0, 0};\n    static int[] dy = {0, 0, -1, 1};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt();\n        m = scanner.nextInt();\n        scanner.nextLine(); // consume the rest of the line\n        grid = new char[n][m];\n        for (int i = 0; i < n; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = line.charAt(j);\n            }\n        }\n\n        int total = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 'Y') {\n                    total += dfs(i, j, 0);\n                }\n            }\n        }\n        System.out.println(total);\n    }\n\n    private static int dfs(int i, int j, int k) {\n        if (k == 7) {\n            return 1;\n        }\n        int res = 0;\n        for (int dir = 0; dir < 4; dir++) {\n            int ni = i + dx[dir];\n            int nj = j + dy[dir];\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n                if (grid[ni][nj] == sequence.charAt(k + 1)) {\n                    res += dfs(ni, nj, k + 1);\n                }\n            }\n        }\n        return res;\n    }\n}",
            "memory": 8,
            "memoryDistribution": "[[8, 0, \"import java.util.*;\\n\\npublic class Main {\\n    static int n, m;\\n    static char[][] grid;\\n    static final String sequence = \\\"YOKOHAMA\\\";\\n    static int[] dx = {-1, 1, 0, 0};\\n    static int[] dy = {0, 0, -1, 1};\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        n = scanner.nextInt();\\n        m = scanner.nextInt();\\n        scanner.nextLine(); // consume the rest of the line\\n        grid = new char[n][m];\\n        for (int i = 0; i < n; i++) {\\n            String line = scanner.nextLine();\\n            for (int j = 0; j < m; j++) {\\n                grid[i][j] = line.charAt(j);\\n            }\\n        }\\n\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 'Y') {\\n                    total += dfs(i, j, 0);\\n                }\\n            }\\n        }\\n        System.out.println(total);\\n    }\\n\\n    private static int dfs(int i, int j, int k) {\\n        if (k == 7) {\\n            return 1;\\n        }\\n        int res = 0;\\n        for (int dir = 0; dir < 4; dir++) {\\n            int ni = i + dx[dir];\\n            int nj = j + dy[dir];\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] == sequence.charAt(k + 1)) {\\n                    res += dfs(ni, nj, k + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\"], [8, 0, \"import java.util.*;\\n\\npublic class Main {\\n    static int n, m;\\n    static char[][] grid;\\n    static final String sequence = \\\"YOKOHAMA\\\";\\n    static int[] dx = {-1, 1, 0, 0};\\n    static int[] dy = {0, 0, -1, 1};\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        n = scanner.nextInt();\\n        m = scanner.nextInt();\\n        scanner.nextLine(); // consume the rest of the line\\n        grid = new char[n][m];\\n        for (int i = 0; i < n; i++) {\\n            String line = scanner.nextLine();\\n            for (int j = 0; j < m; j++) {\\n                grid[i][j] = line.charAt(j);\\n            }\\n        }\\n\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 'Y') {\\n                    total += dfs(i, j, 0);\\n                }\\n            }\\n        }\\n        System.out.println(total);\\n    }\\n\\n    private static int dfs(int i, int j, int k) {\\n        if (k == 7) {\\n            return 1;\\n        }\\n        int res = 0;\\n        for (int dir = 0; dir < 4; dir++) {\\n            int ni = i + dx[dir];\\n            int nj = j + dy[dir];\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] == sequence.charAt(k + 1)) {\\n                    res += dfs(ni, nj, k + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\"], [8, 0, \"import java.util.*;\\n\\npublic class Main {\\n    static int n, m;\\n    static char[][] grid;\\n    static final String sequence = \\\"YOKOHAMA\\\";\\n    static int[] dx = {-1, 1, 0, 0};\\n    static int[] dy = {0, 0, -1, 1};\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        n = scanner.nextInt();\\n        m = scanner.nextInt();\\n        scanner.nextLine(); // consume the rest of the line\\n        grid = new char[n][m];\\n        for (int i = 0; i < n; i++) {\\n            String line = scanner.nextLine();\\n            for (int j = 0; j < m; j++) {\\n                grid[i][j] = line.charAt(j);\\n            }\\n        }\\n\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 'Y') {\\n                    total += dfs(i, j, 0);\\n                }\\n            }\\n        }\\n        System.out.println(total);\\n    }\\n\\n    private static int dfs(int i, int j, int k) {\\n        if (k == 7) {\\n            return 1;\\n        }\\n        int res = 0;\\n        for (int dir = 0; dir < 4; dir++) {\\n            int ni = i + dx[dir];\\n            int nj = j + dy[dir];\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] == sequence.charAt(k + 1)) {\\n                    res += dfs(ni, nj, k + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\"], [8, 0, \"import java.util.*;\\n\\npublic class Main {\\n    static int n, m;\\n    static char[][] grid;\\n    static final String sequence = \\\"YOKOHAMA\\\";\\n    static int[] dx = {-1, 1, 0, 0};\\n    static int[] dy = {0, 0, -1, 1};\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        n = scanner.nextInt();\\n        m = scanner.nextInt();\\n        scanner.nextLine(); // consume the rest of the line\\n        grid = new char[n][m];\\n        for (int i = 0; i < n; i++) {\\n            String line = scanner.nextLine();\\n            for (int j = 0; j < m; j++) {\\n                grid[i][j] = line.charAt(j);\\n            }\\n        }\\n\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 'Y') {\\n                    total += dfs(i, j, 0);\\n                }\\n            }\\n        }\\n        System.out.println(total);\\n    }\\n\\n    private static int dfs(int i, int j, int k) {\\n        if (k == 7) {\\n            return 1;\\n        }\\n        int res = 0;\\n        for (int dir = 0; dir < 4; dir++) {\\n            int ni = i + dx[dir];\\n            int nj = j + dy[dir];\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] == sequence.charAt(k + 1)) {\\n                    res += dfs(ni, nj, k + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\"]]",
            "runtime": 0,
            "runtimeDistribution": "[[0, 0, \"import java.util.*;\\n\\npublic class Main {\\n    static int n, m;\\n    static char[][] grid;\\n    static final String sequence = \\\"YOKOHAMA\\\";\\n    static int[] dx = {-1, 1, 0, 0};\\n    static int[] dy = {0, 0, -1, 1};\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        n = scanner.nextInt();\\n        m = scanner.nextInt();\\n        scanner.nextLine(); // consume the rest of the line\\n        grid = new char[n][m];\\n        for (int i = 0; i < n; i++) {\\n            String line = scanner.nextLine();\\n            for (int j = 0; j < m; j++) {\\n                grid[i][j] = line.charAt(j);\\n            }\\n        }\\n\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 'Y') {\\n                    total += dfs(i, j, 0);\\n                }\\n            }\\n        }\\n        System.out.println(total);\\n    }\\n\\n    private static int dfs(int i, int j, int k) {\\n        if (k == 7) {\\n            return 1;\\n        }\\n        int res = 0;\\n        for (int dir = 0; dir < 4; dir++) {\\n            int ni = i + dx[dir];\\n            int nj = j + dy[dir];\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] == sequence.charAt(k + 1)) {\\n                    res += dfs(ni, nj, k + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\"], [0, 0, \"import java.util.*;\\n\\npublic class Main {\\n    static int n, m;\\n    static char[][] grid;\\n    static final String sequence = \\\"YOKOHAMA\\\";\\n    static int[] dx = {-1, 1, 0, 0};\\n    static int[] dy = {0, 0, -1, 1};\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        n = scanner.nextInt();\\n        m = scanner.nextInt();\\n        scanner.nextLine(); // consume the rest of the line\\n        grid = new char[n][m];\\n        for (int i = 0; i < n; i++) {\\n            String line = scanner.nextLine();\\n            for (int j = 0; j < m; j++) {\\n                grid[i][j] = line.charAt(j);\\n            }\\n        }\\n\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 'Y') {\\n                    total += dfs(i, j, 0);\\n                }\\n            }\\n        }\\n        System.out.println(total);\\n    }\\n\\n    private static int dfs(int i, int j, int k) {\\n        if (k == 7) {\\n            return 1;\\n        }\\n        int res = 0;\\n        for (int dir = 0; dir < 4; dir++) {\\n            int ni = i + dx[dir];\\n            int nj = j + dy[dir];\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] == sequence.charAt(k + 1)) {\\n                    res += dfs(ni, nj, k + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\"], [0, 0, \"import java.util.*;\\n\\npublic class Main {\\n    static int n, m;\\n    static char[][] grid;\\n    static final String sequence = \\\"YOKOHAMA\\\";\\n    static int[] dx = {-1, 1, 0, 0};\\n    static int[] dy = {0, 0, -1, 1};\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        n = scanner.nextInt();\\n        m = scanner.nextInt();\\n        scanner.nextLine(); // consume the rest of the line\\n        grid = new char[n][m];\\n        for (int i = 0; i < n; i++) {\\n            String line = scanner.nextLine();\\n            for (int j = 0; j < m; j++) {\\n                grid[i][j] = line.charAt(j);\\n            }\\n        }\\n\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 'Y') {\\n                    total += dfs(i, j, 0);\\n                }\\n            }\\n        }\\n        System.out.println(total);\\n    }\\n\\n    private static int dfs(int i, int j, int k) {\\n        if (k == 7) {\\n            return 1;\\n        }\\n        int res = 0;\\n        for (int dir = 0; dir < 4; dir++) {\\n            int ni = i + dx[dir];\\n            int nj = j + dy[dir];\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] == sequence.charAt(k + 1)) {\\n                    res += dfs(ni, nj, k + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\"], [0, 0, \"import java.util.*;\\n\\npublic class Main {\\n    static int n, m;\\n    static char[][] grid;\\n    static final String sequence = \\\"YOKOHAMA\\\";\\n    static int[] dx = {-1, 1, 0, 0};\\n    static int[] dy = {0, 0, -1, 1};\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        n = scanner.nextInt();\\n        m = scanner.nextInt();\\n        scanner.nextLine(); // consume the rest of the line\\n        grid = new char[n][m];\\n        for (int i = 0; i < n; i++) {\\n            String line = scanner.nextLine();\\n            for (int j = 0; j < m; j++) {\\n                grid[i][j] = line.charAt(j);\\n            }\\n        }\\n\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 'Y') {\\n                    total += dfs(i, j, 0);\\n                }\\n            }\\n        }\\n        System.out.println(total);\\n    }\\n\\n    private static int dfs(int i, int j, int k) {\\n        if (k == 7) {\\n            return 1;\\n        }\\n        int res = 0;\\n        for (int dir = 0; dir < 4; dir++) {\\n            int ni = i + dx[dir];\\n            int nj = j + dy[dir];\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] == sequence.charAt(k + 1)) {\\n                    res += dfs(ni, nj, k + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\"]]"
        },
        "javascript": {
            "code": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet n, m;\nlet grid = [];\nlet linesRead = 0;\n\nrl.on('line', (line) => {\n    if (linesRead === 0) {\n        [n, m] = line.trim().split(' ').map(Number);\n        linesRead++;\n    } else {\n        grid.push(line.trim());\n        if (grid.length === n) {\n            rl.close();\n        }\n    }\n}).on('close', () => {\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    const sequence = ['Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'];\n    \n    function dfs(i, j, step) {\n        if (step === 7) {\n            return 1;\n        }\n        let count = 0;\n        for (const [di, dj] of directions) {\n            const ni = i + di;\n            const nj = j + dj;\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n                if (grid[ni][nj] === sequence[step + 1]) {\n                    count += dfs(ni, nj, step + 1);\n                }\n            }\n        }\n        return count;\n    }\n    \n    let total = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 'Y') {\n                total += dfs(i, j, 0);\n            }\n        }\n    }\n    \n    console.log(total);\n    process.exit(0);\n});",
            "memory": 8,
            "memoryDistribution": "[[8, 0, \"const readline = require('readline');\\n\\nconst rl = readline.createInterface({\\n    input: process.stdin,\\n    output: process.stdout\\n});\\n\\nlet n, m;\\nlet grid = [];\\nlet linesRead = 0;\\n\\nrl.on('line', (line) => {\\n    if (linesRead === 0) {\\n        [n, m] = line.split(' ').map(Number);\\n        linesRead++;\\n    } else {\\n        grid.push(line.trim());\\n        if (grid.length === n) {\\n            rl.close();\\n        }\\n    }\\n}).on('close', () => {\\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    const sequence = ['Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'];\\n    \\n    function dfs(i, j, step) {\\n        if (step === 7) {\\n            return 1;\\n        }\\n        let count = 0;\\n        for (const [di, dj] of directions) {\\n            const ni = i + di;\\n            const nj = j + dj;\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] === sequence[step + 1]) {\\n                    count += dfs(ni, nj, step + 1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    let total = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (grid[i][j] === 'Y') {\\n                total += dfs(i, j, 0);\\n            }\\n        }\\n    }\\n    \\n    console.log(total);\\n    process.exit(0);\\n});\"], [8, 0, \"const readline = require('readline');\\n\\nconst rl = readline.createInterface({\\n    input: process.stdin,\\n    output: process.stdout\\n});\\n\\nlet n, m;\\nlet grid = [];\\nlet linesRead = 0;\\n\\nrl.on('line', (line) => {\\n    if (linesRead === 0) {\\n        [n, m] = line.trim().split(' ').map(Number);\\n        linesRead++;\\n    } else {\\n        grid.push(line.trim());\\n        if (grid.length === n) {\\n            rl.close();\\n        }\\n    }\\n}).on('close', () => {\\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    const sequence = ['Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'];\\n    \\n    function dfs(i, j, step) {\\n        if (step === 7) {\\n            return 1;\\n        }\\n        let count = 0;\\n        for (const [di, dj] of directions) {\\n            const ni = i + di;\\n            const nj = j + dj;\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] === sequence[step + 1]) {\\n                    count += dfs(ni, nj, step + 1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    let total = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (grid[i][j] === 'Y') {\\n                total += dfs(i, j, 0);\\n            }\\n        }\\n    }\\n    \\n    console.log(total);\\n    process.exit(0);\\n});\"], [8, 0, \"const readline = require('readline');\\n\\nconst rl = readline.createInterface({\\n    input: process.stdin,\\n    output: process.stdout\\n});\\n\\nlet n, m;\\nlet grid = [];\\nlet linesRead = 0;\\n\\nrl.on('line', (line) => {\\n    if (linesRead === 0) {\\n        [n, m] = line.trim().split(' ').map(Number);\\n        linesRead++;\\n    } else {\\n        grid.push(line.trim());\\n        if (grid.length === n) {\\n            rl.close();\\n        }\\n    }\\n}).on('close', () => {\\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    const sequence = ['Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'];\\n    \\n    function dfs(i, j, step) {\\n        if (step === 7) {\\n            return 1;\\n        }\\n        let count = 0;\\n        for (const [di, dj] of directions) {\\n            const ni = i + di;\\n            const nj = j + dj;\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] === sequence[step + 1]) {\\n                    count += dfs(ni, nj, step + 1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    let total = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (grid[i][j] === 'Y') {\\n                total += dfs(i, j, 0);\\n            }\\n        }\\n    }\\n    \\n    console.log(total);\\n    process.exit(0);\\n});\"], [8, 0, \"const readline = require('readline');\\n\\nconst rl = readline.createInterface({\\n    input: process.stdin,\\n    output: process.stdout\\n});\\n\\nlet n, m;\\nlet grid = [];\\nlet linesRead = 0;\\n\\nrl.on('line', (line) => {\\n    if (linesRead === 0) {\\n        [n, m] = line.trim().split(' ').map(Number);\\n        linesRead++;\\n    } else {\\n        grid.push(line.trim());\\n        if (grid.length === n) {\\n            rl.close();\\n        }\\n    }\\n}).on('close', () => {\\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    const sequence = ['Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'];\\n    \\n    function dfs(i, j, step) {\\n        if (step === 7) {\\n            return 1;\\n        }\\n        let count = 0;\\n        for (const [di, dj] of directions) {\\n            const ni = i + di;\\n            const nj = j + dj;\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] === sequence[step + 1]) {\\n                    count += dfs(ni, nj, step + 1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    let total = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (grid[i][j] === 'Y') {\\n                total += dfs(i, j, 0);\\n            }\\n        }\\n    }\\n    \\n    console.log(total);\\n    process.exit(0);\\n});\"], [8, 0, \"const readline = require('readline');\\n\\nconst rl = readline.createInterface({\\n    input: process.stdin,\\n    output: process.stdout\\n});\\n\\nlet n, m;\\nlet grid = [];\\nlet linesRead = 0;\\n\\nrl.on('line', (line) => {\\n    if (linesRead === 0) {\\n        [n, m] = line.trim().split(' ').map(Number);\\n        linesRead++;\\n    } else {\\n        grid.push(line.trim());\\n        if (grid.length === n) {\\n            rl.close();\\n        }\\n    }\\n}).on('close', () => {\\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    const sequence = ['Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'];\\n    \\n    function dfs(i, j, step) {\\n        if (step === 7) {\\n            return 1;\\n        }\\n        let count = 0;\\n        for (const [di, dj] of directions) {\\n            const ni = i + di;\\n            const nj = j + dj;\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] === sequence[step + 1]) {\\n                    count += dfs(ni, nj, step + 1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    let total = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (grid[i][j] === 'Y') {\\n                total += dfs(i, j, 0);\\n            }\\n        }\\n    }\\n    \\n    console.log(total);\\n    process.exit(0);\\n});\"]]",
            "runtime": 0,
            "runtimeDistribution": "[[0, 0, \"const readline = require('readline');\\n\\nconst rl = readline.createInterface({\\n    input: process.stdin,\\n    output: process.stdout\\n});\\n\\nlet n, m;\\nlet grid = [];\\nlet linesRead = 0;\\n\\nrl.on('line', (line) => {\\n    if (linesRead === 0) {\\n        [n, m] = line.split(' ').map(Number);\\n        linesRead++;\\n    } else {\\n        grid.push(line.trim());\\n        if (grid.length === n) {\\n            rl.close();\\n        }\\n    }\\n}).on('close', () => {\\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    const sequence = ['Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'];\\n    \\n    function dfs(i, j, step) {\\n        if (step === 7) {\\n            return 1;\\n        }\\n        let count = 0;\\n        for (const [di, dj] of directions) {\\n            const ni = i + di;\\n            const nj = j + dj;\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] === sequence[step + 1]) {\\n                    count += dfs(ni, nj, step + 1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    let total = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (grid[i][j] === 'Y') {\\n                total += dfs(i, j, 0);\\n            }\\n        }\\n    }\\n    \\n    console.log(total);\\n    process.exit(0);\\n});\"], [0, 0, \"const readline = require('readline');\\n\\nconst rl = readline.createInterface({\\n    input: process.stdin,\\n    output: process.stdout\\n});\\n\\nlet n, m;\\nlet grid = [];\\nlet linesRead = 0;\\n\\nrl.on('line', (line) => {\\n    if (linesRead === 0) {\\n        [n, m] = line.trim().split(' ').map(Number);\\n        linesRead++;\\n    } else {\\n        grid.push(line.trim());\\n        if (grid.length === n) {\\n            rl.close();\\n        }\\n    }\\n}).on('close', () => {\\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    const sequence = ['Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'];\\n    \\n    function dfs(i, j, step) {\\n        if (step === 7) {\\n            return 1;\\n        }\\n        let count = 0;\\n        for (const [di, dj] of directions) {\\n            const ni = i + di;\\n            const nj = j + dj;\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] === sequence[step + 1]) {\\n                    count += dfs(ni, nj, step + 1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    let total = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (grid[i][j] === 'Y') {\\n                total += dfs(i, j, 0);\\n            }\\n        }\\n    }\\n    \\n    console.log(total);\\n    process.exit(0);\\n});\"], [0, 0, \"const readline = require('readline');\\n\\nconst rl = readline.createInterface({\\n    input: process.stdin,\\n    output: process.stdout\\n});\\n\\nlet n, m;\\nlet grid = [];\\nlet linesRead = 0;\\n\\nrl.on('line', (line) => {\\n    if (linesRead === 0) {\\n        [n, m] = line.trim().split(' ').map(Number);\\n        linesRead++;\\n    } else {\\n        grid.push(line.trim());\\n        if (grid.length === n) {\\n            rl.close();\\n        }\\n    }\\n}).on('close', () => {\\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    const sequence = ['Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'];\\n    \\n    function dfs(i, j, step) {\\n        if (step === 7) {\\n            return 1;\\n        }\\n        let count = 0;\\n        for (const [di, dj] of directions) {\\n            const ni = i + di;\\n            const nj = j + dj;\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] === sequence[step + 1]) {\\n                    count += dfs(ni, nj, step + 1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    let total = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (grid[i][j] === 'Y') {\\n                total += dfs(i, j, 0);\\n            }\\n        }\\n    }\\n    \\n    console.log(total);\\n    process.exit(0);\\n});\"], [0, 0, \"const readline = require('readline');\\n\\nconst rl = readline.createInterface({\\n    input: process.stdin,\\n    output: process.stdout\\n});\\n\\nlet n, m;\\nlet grid = [];\\nlet linesRead = 0;\\n\\nrl.on('line', (line) => {\\n    if (linesRead === 0) {\\n        [n, m] = line.trim().split(' ').map(Number);\\n        linesRead++;\\n    } else {\\n        grid.push(line.trim());\\n        if (grid.length === n) {\\n            rl.close();\\n        }\\n    }\\n}).on('close', () => {\\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    const sequence = ['Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'];\\n    \\n    function dfs(i, j, step) {\\n        if (step === 7) {\\n            return 1;\\n        }\\n        let count = 0;\\n        for (const [di, dj] of directions) {\\n            const ni = i + di;\\n            const nj = j + dj;\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] === sequence[step + 1]) {\\n                    count += dfs(ni, nj, step + 1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    let total = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (grid[i][j] === 'Y') {\\n                total += dfs(i, j, 0);\\n            }\\n        }\\n    }\\n    \\n    console.log(total);\\n    process.exit(0);\\n});\"], [0, 0, \"const readline = require('readline');\\n\\nconst rl = readline.createInterface({\\n    input: process.stdin,\\n    output: process.stdout\\n});\\n\\nlet n, m;\\nlet grid = [];\\nlet linesRead = 0;\\n\\nrl.on('line', (line) => {\\n    if (linesRead === 0) {\\n        [n, m] = line.trim().split(' ').map(Number);\\n        linesRead++;\\n    } else {\\n        grid.push(line.trim());\\n        if (grid.length === n) {\\n            rl.close();\\n        }\\n    }\\n}).on('close', () => {\\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    const sequence = ['Y', 'O', 'K', 'O', 'H', 'A', 'M', 'A'];\\n    \\n    function dfs(i, j, step) {\\n        if (step === 7) {\\n            return 1;\\n        }\\n        let count = 0;\\n        for (const [di, dj] of directions) {\\n            const ni = i + di;\\n            const nj = j + dj;\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\\n                if (grid[ni][nj] === sequence[step + 1]) {\\n                    count += dfs(ni, nj, step + 1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    let total = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (grid[i][j] === 'Y') {\\n                total += dfs(i, j, 0);\\n            }\\n        }\\n    }\\n    \\n    console.log(total);\\n    process.exit(0);\\n});\"]]"
        },
        "python3": {
            "code": "# ICPC_1444\nn, m = map(int, input().split())\nx = [input() for _ in range(n)]\n\ndef dfs(i, j, k=0):\n    if k==7:\n        return 1\n    res = 0\n    for di, dj in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n        if not (0<=i+di<n and 0<=j+dj<m):\n            continue\n        if x[i+di][j+dj]!=\"YOKOHAMA\"[k+1]:\n            continue\n        res += dfs(i+di, j+dj, k+1)\n    return res\n\nans = 0\nfor i in range(n):\n    for j in range(m):\n        if x[i][j]==\"Y\":\n            ans += dfs(i, j)\nprint(ans)",
            "memory": 8,
            "memoryDistribution": "[[8, 0, \"# ICPC_1444\\nn, m = map(int, input().split())\\nx = [input() for _ in range(n)]\\n\\ndef dfs(i, j, k=0):\\n    if k==7:\\n        return 1\\n    res = 0\\n    for di, dj in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n        if not (0<=i+di<n and 0<=j+dj<m):\\n            continue\\n        if x[i+di][j+dj]!=\\\"YOKOHAMA\\\"[k+1]:\\n            continue\\n        res += dfs(i+di, j+dj, k+1)\\n    return res\\n\\nans = 0\\nfor i in range(n):\\n    for j in range(m):\\n        if x[i][j]==\\\"Y\\\":\\n            ans += dfs(i, j)\\nprint(ans)\"]]",
            "runtime": 0,
            "runtimeDistribution": "[[0, 0, \"# ICPC_1444\\nn, m = map(int, input().split())\\nx = [input() for _ in range(n)]\\n\\ndef dfs(i, j, k=0):\\n    if k==7:\\n        return 1\\n    res = 0\\n    for di, dj in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n        if not (0<=i+di<n and 0<=j+dj<m):\\n            continue\\n        if x[i+di][j+dj]!=\\\"YOKOHAMA\\\"[k+1]:\\n            continue\\n        res += dfs(i+di, j+dj, k+1)\\n    return res\\n\\nans = 0\\nfor i in range(n):\\n    for j in range(m):\\n        if x[i][j]==\\\"Y\\\":\\n            ans += dfs(i, j)\\nprint(ans)\"]]"
        },
        "ruby": {
            "code": "h, w = gets.chomp.split.map(&:to_i)\nboard = [\"#\" * (w + 2)]\nh.times{board << \"#\" + gets.chomp + \"#\"}\nboard << \"#\" * (w + 2)\n\ntemp = []\n1.upto(h){|i| 1.upto(w){|j| temp << [i, j, 1] if board[i][j] == \"Y\"}}\nyokohama = \"YOKOHAMA\"\nresult = 0\nidx = 0\nwhile idx < temp.length\n    i, j, k = temp[idx]\n    idx += 1\n    if k == 8\n        result += 1\n        next\n    end\n    [[i+1, j], [i-1, j], [i, j+1], [i, j-1]].each{|y, x|\n        temp << [y, x, k + 1] if board[y][x] == yokohama[k]\n    }\nend\nputs result",
            "memory": 8,
            "memoryDistribution": "[[8, 0, \"h, w = gets.chomp.split.map(&:to_i)\\nboard = [\\\"#\\\" * (w + 2)]\\nh.times{board << \\\"#\\\" + gets.chomp + \\\"#\\\"}\\nboard << \\\"#\\\" * (w + 2)\\n\\ntemp = []\\n1.upto(h){|i| 1.upto(w){|j| temp << [i, j, 1] if board[i][j] == \\\"Y\\\"}}\\nyokohama = \\\"YOKOHAMA\\\"\\nresult = 0\\nidx = 0\\nwhile idx < temp.length\\n    i, j, k = temp[idx]\\n    idx += 1\\n    if k == 8\\n        result += 1\\n        next\\n    end\\n    [[i+1, j], [i-1, j], [i, j+1], [i, j-1]].each{|y, x|\\n        temp << [y, x, k + 1] if board[y][x] == yokohama[k]\\n    }\\nend\\nputs result\"]]",
            "runtime": 40,
            "runtimeDistribution": "[[40, 0, \"h, w = gets.chomp.split.map(&:to_i)\\nboard = [\\\"#\\\" * (w + 2)]\\nh.times{board << \\\"#\\\" + gets.chomp + \\\"#\\\"}\\nboard << \\\"#\\\" * (w + 2)\\n\\ntemp = []\\n1.upto(h){|i| 1.upto(w){|j| temp << [i, j, 1] if board[i][j] == \\\"Y\\\"}}\\nyokohama = \\\"YOKOHAMA\\\"\\nresult = 0\\nidx = 0\\nwhile idx < temp.length\\n    i, j, k = temp[idx]\\n    idx += 1\\n    if k == 8\\n        result += 1\\n        next\\n    end\\n    [[i+1, j], [i-1, j], [i, j+1], [i, j-1]].each{|y, x|\\n        temp << [y, x, k + 1] if board[y][x] == yokohama[k]\\n    }\\nend\\nputs result\"]]"
        }
    },
    "test_case_generator": "def generate_test_cases(num_cases: int, seed: int = 42) -> list[dict]:\n    import random\n    # collections is not strictly needed for the current DFS implementation\n    # import collections \n\n    random.seed(seed)\n\n    # --- Solver (adapted from problem description) ---\n    # Memoization cache for the DFS. Must be reset for each call to solve_yokohama.\n    _solver_memo_cache = {} \n\n    def _dfs_solver(r: int, c: int, k: int, n_val: int, m_val: int, grid_val: list[str], target_seq: str) -> int:\n        state = (r, c, k)\n        if state in _solver_memo_cache:\n            return _solver_memo_cache[state]\n\n        # Base case: successfully found the entire \"YOKOHAMA\" sequence.\n        # k is the index of the character just placed.\n        # target_seq has length 8 (indices 0-7).\n        # If k == 7, it means the 8th character (target_seq[7]) has been placed.\n        if k == len(target_seq) - 1: \n            return 1\n        \n        count = 0\n        # Moves: up, down, left, right\n        # (dr, dc) pairs for (-1,0), (1,0), (0,-1), (0,1)\n        dr = [-1, 1, 0, 0]\n        dc = [0, 0, -1, 1]\n\n        for i in range(4): # Iterate over 4 possible directions\n            nr, nc = r + dr[i], c + dc[i]\n\n            if 0 <= nr < n_val and 0 <= nc < m_val:\n                # Check if the character in the next square matches the next character in the target sequence\n                if grid_val[nr][nc] == target_seq[k+1]:\n                    count += _dfs_solver(nr, nc, k + 1, n_val, m_val, grid_val, target_seq)\n        \n        _solver_memo_cache[state] = count\n        return count\n\n    def solve_yokohama(n_val: int, m_val: int, grid_val: list[str]) -> int:\n        _solver_memo_cache.clear() # Reset memoization for each new grid processing\n        \n        target_sequence = \"YOKOHAMA\" # The sequence to find\n        total_traces = 0\n\n        # Validate inputs based on problem constraints (optional here, assuming valid inputs from generator)\n        # if not (1 <= n_val <= 10 and 1 <= m_val <= 10): return 0\n        # if not grid_val or len(grid_val) != n_val or not all(len(row) == m_val for row in grid_val): return 0\n\n        for r_start in range(n_val):\n            for c_start in range(m_val):\n                # Start DFS if the current square matches the first character of the sequence ('Y')\n                if grid_val[r_start][c_start] == target_sequence[0]:\n                    # k=0 means we are at the first char 'Y' (index 0 of target_sequence)\n                    total_traces += _dfs_solver(r_start, c_start, 0, n_val, m_val, grid_val, target_sequence)\n        return total_traces\n\n    # --- Serialization helpers ---\n    def serialize_input(n_val: int, m_val: int, grid_val: list[str]) -> str:\n        input_lines = [f\"{n_val} {m_val}\"]\n        input_lines.extend(grid_val) # grid_val is list of strings, each representing a row\n        return \"\\n\".join(input_lines)\n\n    def serialize_output(count: int) -> str:\n        return str(count)\n\n    test_cases = []\n    seen_inputs = set() # To ensure unique test cases by input string\n    \n    letters_pool = \"AHKMOY\" # Allowed characters in the grid\n\n    # Define a list of generator functions for specific categories of test cases\n    # Each generator yields (n, m, grid_list_of_strings) tuples\n    \n    case_generators = []\n\n    # Generator 1: Sample Inputs from problem description\n    def gen_sample_cases():\n        yield (2, 4, [\"YOHA\", \"OKAM\"])\n        yield (3, 4, [\"YOKH\", \"OKHA\", \"KHAM\"])\n        yield (3, 6, [\"MAYOHA\", \"AHOKAM\", \"MAYOHA\"])\n    case_generators.append(gen_sample_cases)\n\n    # Generator 2: Boundary dimensions and simple content\n    def gen_boundary_dim_cases():\n        # 1x1 grids\n        for char_code in letters_pool:\n            yield 1, 1, [char_code]\n        \n        # Max dimensions (10x10)\n        yield 10, 10, [\"\".join(random.choices(letters_pool, k=10)) for _ in range(10)] # Random content\n        yield 10, 10, ['Y'*10 for _ in range(10)] # All 'Y's\n        yield 10, 10, ['A'*10 for _ in range(10)] # All 'A's (no 'Y', so 0 traces)\n        \n        # Min one dimension, Max other (e.g., 1x10, 10x1)\n        yield 1, 10, [\"\".join(random.choices(letters_pool, k=10))]\n        # For Nx1 grid: list of N single-char strings. e.g. for 10x1, 10 strings of length 1.\n        yield 10, 1, [random.choice(letters_pool) for _ in range(10)] \n        \n        # Grids that exactly spell \"YOKOHAMA\" or parts of it\n        yield 1, 8, [\"YOKOHAMA\"] # Expected: 1 trace\n        yield 8, 1, list(\"YOKOHAMA\") # list(\"S\") -> ['S'], so this is correct for Nx1\n        yield 1, 7, [\"YOKOHAM\"] # Incomplete, expected: 0 traces\n        yield 1, 9, [\"YOKOHAMAA\"] # Valid path + extra char, expected: 1 trace\n        \n    case_generators.append(gen_boundary_dim_cases)\n\n    # Generator 3: Specific patterns and edge cases\n    def gen_pattern_cases():\n        # All same character for various small/medium sizes\n        for char_code in letters_pool:\n            n, m = random.randint(3,6), random.randint(3,6)\n            yield n, m, [char_code * m for _ in range(n)]\n        \n        # Grid with no 'Y' characters\n        n, m = random.randint(4,7), random.randint(4,7)\n        yield n, m, [\"\".join(random.choices(\"OKAHM\", k=m)) for _ in range(n)]\n        \n        # Grid with only 'Y' and 'O' characters\n        n, m = random.randint(3,5), random.randint(3,5)\n        yield n, m, [\"\".join(random.choices(\"YO\", k=m)) for _ in range(n)]\n\n        # A manually crafted grid with a known path structure\n        # Path: Y(0,0) O(0,1) K(1,1) O(2,1) H(3,1) A(3,2) M(2,2) A(1,2)\n        yield 4, 3, [\"YOA\", \"AKA\", \"AOM\", \"AHA\"]\n\n        # Grid designed to test revisiting a square (O-K-O part)\n        # Path: Y(0,0) O(0,1) K(1,0) O(0,1) H(2,0) A(2,1) M(2,2) A(3,3)\n        yield 4, 4, [\"YOAA\", \"KOAA\", \"HAMA\", \"AAAA\"] # 'A's are fillers\n\n    case_generators.append(gen_pattern_cases)\n\n    # Process predefined cases from generators\n    for generator_func in case_generators:\n        if len(test_cases) >= num_cases:\n            break\n        for n_val, m_val, grid_val_list in generator_func():\n            if len(test_cases) >= num_cases:\n                break\n            \n            s_input = serialize_input(n_val, m_val, grid_val_list)\n            if s_input not in seen_inputs:\n                s_output = serialize_output(solve_yokohama(n_val, m_val, grid_val_list))\n                test_cases.append({\"input\": s_input, \"output\": s_output})\n                seen_inputs.add(s_input)\n\n    # Fill remaining test case slots with randomly generated grids\n    while len(test_cases) < num_cases:\n        n_val = random.randint(1, 10)\n        m_val = random.randint(1, 10)\n        \n        current_grid_val = []\n        # Strategy for random grid content\n        grid_content_roll = random.random()\n        if grid_content_roll < 0.7: # 70% chance: Purely random characters\n            current_grid_val = [\"\".join(random.choices(letters_pool, k=m_val)) for _ in range(n_val)]\n        elif grid_content_roll < 0.9: # 20% chance: 'Y'-heavy grid\n            rows = []\n            for _ in range(n_val):\n                row_chars = []\n                for _ in range(m_val):\n                    if random.random() < 0.35: # 35% chance for a 'Y'\n                        row_chars.append('Y')\n                    else:\n                        row_chars.append(random.choice(\"OKAHM\")) # Other non-'Y' critical path letters\n                rows.append(\"\".join(row_chars))\n            current_grid_val = rows\n        else: # 10% chance: Grid filled with a single character\n            char_to_fill = random.choice(letters_pool)\n            current_grid_val = [char_to_fill * m_val for _ in range(n_val)]\n\n        s_input = serialize_input(n_val, m_val, current_grid_val)\n        if s_input not in seen_inputs:\n            s_output = serialize_output(solve_yokohama(n_val, m_val, current_grid_val))\n            test_cases.append({\"input\": s_input, \"output\": s_output})\n            seen_inputs.add(s_input)\n            \n    return test_cases[:num_cases] # Ensure exactly num_cases are returned",
    "evaluator": "def evaluate(expected_output: str, program_output: str) -> bool:\n    import math # Required by instructions, though not used for this integer-only problem.\n                # Kept for adherence, can be removed if strictly not needed.\n\n    # --- Deserialization logic (must be independent) ---\n    # This problem's output is a single integer.\n    def deserialize_single_integer(s: str) -> int:\n        # Handle potential surrounding whitespace from program output\n        cleaned_s = s.strip()\n        if not cleaned_s: # Empty string after strip\n            raise ValueError(\"Output string is empty or only whitespace.\")\n        try:\n            return int(cleaned_s)\n        except ValueError as e:\n            # Re-raise with a more specific message if needed, or just let it propagate\n            raise ValueError(f\"Cannot parse '{cleaned_s}' as an integer: {e}\")\n\n    try:\n        expected_val = deserialize_single_integer(expected_output)\n        # Program output might have extra newlines, etc. strip() handles this.\n        actual_val = deserialize_single_integer(program_output) \n    except ValueError:\n        # If deserialization fails for either string, it's a mismatch.\n        return False\n\n    # Direct comparison for integer values.\n    # The problem does not involve floating point numbers, so math.isclose is not needed here.\n    # If it did, the comparison would be: math.isclose(expected_val, actual_val, rel_tol=..., abs_tol=...)\n    return expected_val == actual_val",
    "generated_tests": "[{\"input\": \"2 4\\nYOHA\\nOKAM\", \"output\": \"8\"}, {\"input\": \"3 4\\nYOKH\\nOKHA\\nKHAM\", \"output\": \"0\"}, {\"input\": \"3 6\\nMAYOHA\\nAHOKAM\\nMAYOHA\", \"output\": \"80\"}, {\"input\": \"1 1\\nA\", \"output\": \"0\"}, {\"input\": \"1 1\\nH\", \"output\": \"0\"}, {\"input\": \"1 1\\nK\", \"output\": \"0\"}, {\"input\": \"1 1\\nM\", \"output\": \"0\"}, {\"input\": \"1 1\\nO\", \"output\": \"0\"}, {\"input\": \"1 1\\nY\", \"output\": \"0\"}, {\"input\": \"10 10\\nMAHHOOYAKA\\nHMAHMMHMOA\\nOOKAYKAAYM\\nOOMYKMOMYM\\nOAHHAHAHMK\\nKHHYMMHOAK\\nYMMOYOHAHH\\nHYYHMKYKHH\\nMHMYKHYMAA\\nAMOKAKYMYY\", \"output\": \"0\"}, {\"input\": \"10 10\\nYYYYYYYYYY\\nYYYYYYYYYY\\nYYYYYYYYYY\\nYYYYYYYYYY\\nYYYYYYYYYY\\nYYYYYYYYYY\\nYYYYYYYYYY\\nYYYYYYYYYY\\nYYYYYYYYYY\\nYYYYYYYYYY\", \"output\": \"0\"}, {\"input\": \"10 10\\nAAAAAAAAAA\\nAAAAAAAAAA\\nAAAAAAAAAA\\nAAAAAAAAAA\\nAAAAAAAAAA\\nAAAAAAAAAA\\nAAAAAAAAAA\\nAAAAAAAAAA\\nAAAAAAAAAA\\nAAAAAAAAAA\", \"output\": \"0\"}, {\"input\": \"1 10\\nAOOMHMAKKY\", \"output\": \"0\"}, {\"input\": \"10 1\\nY\\nK\\nO\\nH\\nO\\nA\\nY\\nK\\nY\\nO\", \"output\": \"0\"}, {\"input\": \"1 8\\nYOKOHAMA\", \"output\": \"2\"}, {\"input\": \"8 1\\nY\\nO\\nK\\nO\\nH\\nA\\nM\\nA\", \"output\": \"2\"}, {\"input\": \"1 7\\nYOKOHAM\", \"output\": \"1\"}, {\"input\": \"1 9\\nYOKOHAMAA\", \"output\": \"2\"}, {\"input\": \"4 4\\nAAAA\\nAAAA\\nAAAA\\nAAAA\", \"output\": \"0\"}, {\"input\": \"5 4\\nHHHH\\nHHHH\\nHHHH\\nHHHH\\nHHHH\", \"output\": \"0\"}, {\"input\": \"3 5\\nKKKKK\\nKKKKK\\nKKKKK\", \"output\": \"0\"}, {\"input\": \"6 3\\nMMM\\nMMM\\nMMM\\nMMM\\nMMM\\nMMM\", \"output\": \"0\"}, {\"input\": \"3 5\\nOOOOO\\nOOOOO\\nOOOOO\", \"output\": \"0\"}, {\"input\": \"5 4\\nYYYY\\nYYYY\\nYYYY\\nYYYY\\nYYYY\", \"output\": \"0\"}, {\"input\": \"4 5\\nMMOAO\\nHHOAA\\nKMAKA\\nHKKMH\", \"output\": \"0\"}, {\"input\": \"4 5\\nYYYYO\\nOYOYY\\nYYOYY\\nOOOOY\", \"output\": \"0\"}, {\"input\": \"4 3\\nYOA\\nAKA\\nAOM\\nAHA\", \"output\": \"2\"}, {\"input\": \"4 4\\nYOAA\\nKOAA\\nHAMA\\nAAAA\", \"output\": \"0\"}, {\"input\": \"8 7\\nAKKKOOY\\nAKKYHHK\\nKHHYKYM\\nAYYYYYA\\nKHKAKYH\\nOKKYYMO\\nAHYMMOA\\nMMYAYAH\", \"output\": \"0\"}, {\"input\": \"10 2\\nHA\\nYH\\nMM\\nKM\\nMY\\nHO\\nHK\\nOH\\nHO\\nAK\", \"output\": \"0\"}, {\"input\": \"10 2\\nHH\\nYY\\nYK\\nAY\\nOM\\nYM\\nAO\\nHM\\nYA\\nAA\", \"output\": \"0\"}, {\"input\": \"9 3\\nMOH\\nMHK\\nYYA\\nKHA\\nOMH\\nOMK\\nAAY\\nYMY\\nMAA\", \"output\": \"0\"}, {\"input\": \"5 6\\nOKOMHK\\nKKOYHK\\nYOOKYA\\nYKYHYA\\nMMYYAY\", \"output\": \"0\"}, {\"input\": \"5 1\\nK\\nO\\nH\\nM\\nM\", \"output\": \"0\"}, {\"input\": \"7 10\\nAKMOOYOHKY\\nYMMAYMOHOM\\nHMKOHMKYHH\\nOMHKOMOYOM\\nHMMAYHHOAA\\nYMOKYMOKKA\\nOYYYOHOOKM\", \"output\": \"0\"}, {\"input\": \"2 8\\nKMMHOKOY\\nKYKAYKOY\", \"output\": \"0\"}, {\"input\": \"5 9\\nHKOHKYAAK\\nAHKHKAOKO\\nYAYMKYHKY\\nYMOOYKHKK\\nOOOYYYMYM\", \"output\": \"0\"}, {\"input\": \"1 2\\nAK\", \"output\": \"0\"}, {\"input\": \"1 5\\nHHOKO\", \"output\": \"0\"}, {\"input\": \"7 5\\nMYKOK\\nYYYYM\\nHAYOK\\nOAHKY\\nKYMMA\\nAYOHY\\nHHYAM\", \"output\": \"0\"}, {\"input\": \"8 8\\nOHYOAYHK\\nMKAYHHOK\\nYOHAYAOK\\nOOMKOAHO\\nHMKMKOHO\\nHHAHAMOH\\nHKOYMHAH\\nHHAMHYMO\", \"output\": \"0\"}, {\"input\": \"3 8\\nAHKKYHYA\\nAKMOAOYA\\nHMKMMOKY\", \"output\": \"0\"}, {\"input\": \"5 10\\nKKKKKKKKKK\\nKKKKKKKKKK\\nKKKKKKKKKK\\nKKKKKKKKKK\\nKKKKKKKKKK\", \"output\": \"0\"}, {\"input\": \"10 10\\nYAOMHAHMAK\\nOKAHHYAHHO\\nMOHAHAHAAO\\nMOYKKHKHMK\\nMYOMAHOYMA\\nOOMOHMKHYK\\nOYKKHAAKKM\\nKOAAHAOYOA\\nYKAMMKKAHA\\nHYKAMOOHAK\", \"output\": \"2\"}, {\"input\": \"4 2\\nAO\\nKO\\nMH\\nYY\", \"output\": \"0\"}, {\"input\": \"4 8\\nKYMYYHOK\\nYMOHHMYK\\nAMKMMKHH\\nOMHOAOOO\", \"output\": \"0\"}, {\"input\": \"7 3\\nAMM\\nYYK\\nMKO\\nKMA\\nKYK\\nOMY\\nYYK\", \"output\": \"0\"}, {\"input\": \"6 8\\nYYAOOOAO\\nYYHYMKYY\\nMHKYHYYA\\nKYMYAAYH\\nYAAYHYOH\\nAKAYYYKO\", \"output\": \"0\"}, {\"input\": \"5 8\\nKAYHKHOY\\nKMHAYYYH\\nYOKAOHOO\\nKYMAKHAK\\nOHKMKOKM\", \"output\": \"0\"}, {\"input\": \"9 6\\nHHHHHH\\nHHHHHH\\nHHHHHH\\nHHHHHH\\nHHHHHH\\nHHHHHH\\nHHHHHH\\nHHHHHH\\nHHHHHH\", \"output\": \"0\"}, {\"input\": \"2 8\\nKKKKKKKK\\nKKKKKKKK\", \"output\": \"0\"}, {\"input\": \"7 2\\nYH\\nKA\\nYA\\nKO\\nOY\\nKO\\nAK\", \"output\": \"0\"}, {\"input\": \"2 8\\nYHOHKHKY\\nKYMAHYYO\", \"output\": \"0\"}, {\"input\": \"2 4\\nMAOH\\nAMAO\", \"output\": \"0\"}, {\"input\": \"4 10\\nYHAYAYAAHH\\nMAAOHHHAOM\\nOKOMAMYAOY\\nMKYAKKOKYA\", \"output\": \"0\"}, {\"input\": \"2 6\\nAHMMHY\\nMKMAOY\", \"output\": \"0\"}, {\"input\": \"9 4\\nYKOK\\nOHHH\\nYOKA\\nAKOK\\nAAYM\\nOKYY\\nKYAH\\nHAMA\\nKYKM\", \"output\": \"0\"}, {\"input\": \"2 5\\nOYYOM\\nMAYOH\", \"output\": \"0\"}, {\"input\": \"3 5\\nYYYMO\\nYOYHA\\nYYYMY\", \"output\": \"0\"}, {\"input\": \"1 3\\nMOH\", \"output\": \"0\"}, {\"input\": \"7 8\\nKHMKAOMM\\nHHYAHYOO\\nHAKKAMHM\\nOKKOKKAH\\nKKMHKYHY\\nKOKKAKKA\\nYOHOAMMH\", \"output\": \"0\"}, {\"input\": \"6 6\\nKYYYOY\\nHMHMMY\\nAYYAMY\\nAOYOOM\\nMOMAMY\\nYYAOKY\", \"output\": \"0\"}, {\"input\": \"8 8\\nMKYKOOAM\\nKHMKHYYM\\nAAMYHMMA\\nOAMMHAOY\\nYYAOMAHY\\nKOHYAHOM\\nMOMMYMMA\\nHOMYOAKO\", \"output\": \"2\"}, {\"input\": \"8 10\\nOKMHOKYKYY\\nKHKMYOOAHM\\nYMAYYHOHYA\\nKYHKKAAMHY\\nKAYYMOAHOO\\nAOKAAHYMOM\\nAHHAKOKAYM\\nAMHAKMHKMA\", \"output\": \"0\"}, {\"input\": \"6 2\\nOO\\nOO\\nOO\\nOO\\nOO\\nOO\", \"output\": \"0\"}, {\"input\": \"9 9\\nKKMYHAOKO\\nMOOHAMOHO\\nKOMOAOKHA\\nHAYMYMHOH\\nKOYHAKYOY\\nKYKKYMOOA\\nMOMHAMHMK\\nOKAYKYHYY\\nAMKOOYAMO\", \"output\": \"0\"}, {\"input\": \"1 3\\nOKK\", \"output\": \"0\"}, {\"input\": \"10 1\\nO\\nY\\nK\\nO\\nM\\nM\\nK\\nM\\nH\\nA\", \"output\": \"0\"}, {\"input\": \"3 8\\nYAOOHMOY\\nHAAHOYOY\\nYOOMHHAO\", \"output\": \"0\"}, {\"input\": \"3 6\\nAHAOAM\\nKOMMAH\\nYOMOOA\", \"output\": \"0\"}, {\"input\": \"6 2\\nOK\\nYO\\nMH\\nYK\\nYA\\nAA\", \"output\": \"0\"}, {\"input\": \"3 3\\nOKY\\nYYH\\nMMA\", \"output\": \"0\"}, {\"input\": \"5 10\\nMHYAMOMYMO\\nAAMMMOKMKM\\nHYKOOHAAKK\\nHMHOOYYAKM\\nHKHHAHKMHY\", \"output\": \"0\"}, {\"input\": \"3 6\\nYYYYYY\\nYYYYYY\\nYYYYYY\", \"output\": \"0\"}, {\"input\": \"6 4\\nMAOM\\nKYOY\\nHYYY\\nYYHH\\nYAOH\\nAMOY\", \"output\": \"0\"}, {\"input\": \"2 7\\nYMKAMKA\\nAOOMAYA\", \"output\": \"0\"}, {\"input\": \"10 6\\nYOHKOM\\nOHOKOY\\nMOOOAK\\nYOOMOM\\nHMMYAO\\nAYAAHA\\nOKOYYO\\nAAHHMM\\nHHYKKO\\nOMOMHH\", \"output\": \"0\"}, {\"input\": \"9 5\\nYHHHO\\nHKYOH\\nAOKYO\\nYOHHO\\nKKHKH\\nMYOAM\\nMHOMM\\nAKOAO\\nAMYKY\", \"output\": \"0\"}, {\"input\": \"8 8\\nOHHAOMHO\\nYAYKYYAY\\nOHOYHAHM\\nYKKMMYAM\\nHOHOMOAK\\nHOHMMKKH\\nKAYKYAKK\\nHHMMHKHO\", \"output\": \"0\"}, {\"input\": \"8 5\\nOYYOO\\nMYKHY\\nKKYKO\\nYOOOO\\nOMOMM\\nKYAOY\\nHMAYK\\nOOKYK\", \"output\": \"0\"}, {\"input\": \"1 8\\nKMMOHAHA\", \"output\": \"0\"}, {\"input\": \"4 10\\nKOMAYYKHHA\\nMOYKYKYKAY\\nYAYAYKAYYO\\nYKOKKHKAHY\", \"output\": \"0\"}, {\"input\": \"2 1\\nO\\nY\", \"output\": \"0\"}, {\"input\": \"2 2\\nKO\\nYH\", \"output\": \"0\"}, {\"input\": \"1 7\\nMOOAYHY\", \"output\": \"0\"}, {\"input\": \"10 6\\nOOHYYM\\nKHMMOH\\nOMAKMK\\nMOKHHM\\nHHYAKA\\nKKMKHH\\nAKKMOA\\nKMAAOM\\nOHHYHY\\nHHOOOY\", \"output\": \"0\"}, {\"input\": \"10 4\\nHHHK\\nMHKY\\nKOOO\\nHHHA\\nYOAM\\nMOHH\\nHMHM\\nYKOK\\nOOKO\\nKAMH\", \"output\": \"0\"}, {\"input\": \"9 1\\nY\\nA\\nO\\nA\\nA\\nA\\nM\\nA\\nA\", \"output\": \"0\"}, {\"input\": \"4 9\\nAMYYMAMKA\\nOMHMOKYHY\\nMHMHKOAYK\\nHOHOAYMAK\", \"output\": \"0\"}, {\"input\": \"7 9\\nMOAYMHYYY\\nYHYOMHYOH\\nMMHYAHAOO\\nYHMMYOMKO\\nOOAOKAHAM\\nMMYHMOKHM\\nKHMKOHHAH\", \"output\": \"0\"}, {\"input\": \"7 3\\nYYY\\nYAY\\nYMH\\nYYM\\nAOY\\nOMK\\nKKY\", \"output\": \"0\"}, {\"input\": \"5 5\\nAKKKA\\nHHMMH\\nAHYHM\\nOHKOY\\nYAHYH\", \"output\": \"0\"}, {\"input\": \"6 3\\nKKK\\nKKK\\nKKK\\nKKK\\nKKK\\nKKK\", \"output\": \"0\"}, {\"input\": \"5 8\\nHHHHHHHH\\nHHHHHHHH\\nHHHHHHHH\\nHHHHHHHH\\nHHHHHHHH\", \"output\": \"0\"}, {\"input\": \"6 7\\nOKYHYHO\\nAOYHOOA\\nYOOAHHA\\nKKKMMMY\\nYKAYOOM\\nYAHMAMM\", \"output\": \"0\"}, {\"input\": \"7 6\\nMMMMMM\\nMMMMMM\\nMMMMMM\\nMMMMMM\\nMMMMMM\\nMMMMMM\\nMMMMMM\", \"output\": \"0\"}, {\"input\": \"2 1\\nH\\nO\", \"output\": \"0\"}, {\"input\": \"9 10\\nHKKOOAYKHY\\nAOOKKOMKAO\\nKAAOAKAOYO\\nMMHKKOMHMK\\nOYKKAHHOOM\\nOMKHAOKYHK\\nKAKKHOOYMO\\nHHAKAKMMKK\\nMYYHHHHYMY\", \"output\": \"0\"}, {\"input\": \"1 8\\nOYMKOKYK\", \"output\": \"0\"}, {\"input\": \"2 10\\nOHHMHKOOMA\\nAOOKOAOMYA\", \"output\": \"0\"}]",
    "test_runners": null
}