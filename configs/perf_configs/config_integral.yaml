# PerfAgent 配置文件示例（新格式：通用字段 + task_config）

# 迭代控制
max_iterations: 1
early_stop_no_improve: 0
adopt_only_if_improved: false
# metric 比较方向：false=越小越好(默认)，true=越大越好
# 对于 EffiBench integral 任务，metric 越小越好
metric_higher_is_better: false

# 模型配置
model:
  name: 
  api_base: 
  api_key: 
  temperature: 0.7
  max_input_tokens: 50000
  max_output_tokens: 20000
  use_llm: false
  # LLM 请求控制与日志开关
  request_timeout: 120
  max_retries: 10
  retry_delay: 2.0
  retry_backoff_factor: 2.0
  retry_jitter: 0.5
  log_inputs_outputs: true
  log_sanitize: true

# 轨迹与日志
logging:
  save_trajectory: true
  trajectory_dir: "./perfagent/trajectories"
  log_dir: "./perfagent/logs"
  log_level: "DEBUG"

# 提示词（留空则会加载默认模板）
prompts:
  system_template: |
    You are an expert competitive programmer specializing in algorithm optimization.

    ## Principles
    1. **Correctness First**: Ensure correctness before optimizing for {optimization_target}.
    2. **Algorithmic Focus**: Prefer algorithmic improvements over micro-optimizations. Explore directions **different from existing approaches**.
    3. **Learn from Failures**: Use Memory to prune failed directions, but don't restrict creative exploration.
    4. **Strict Improvement**: Your solution must outperform the best prior solution in `Additional Requirements`.

    ## Task
    Synthesize a **complete program in {language}** that:
    - Fixes fundamental bottlenecks in current solutions
    - Explores novel optimization directions
    - Minimizes the **integral** (area under memory-time curve) across all test cases — balancing both runtime and memory

    ## Problem
    {task_description}

    ## Response Format
    ### 1. Thinking
    - **Baseline Analysis**: Identify strategy mode and best baseline from `Additional Requirements`.
    - **Failure Pruning**: Review failed directions from Memory; avoid repeating them.
    - **New Direction**: Select a fundamentally different, high-potential approach. Justify why it's better for {optimization_target}.
    - **Risks**: Note correctness concerns and trade-offs.

    ### 2. Final Code
    Complete, self-contained {language} program. No test harness or debug prints.

    ## Allowed Imports
    {allowed_imports_scope}

    ## Context
    **Additional Requirements**: {additional_requirements}
    **Local Memory**: {local_memory}
    **Global Memory**: {global_memory}

  optimization_template: |
    Using all context (Additional Requirements, Local/Global Memory, current program), generate `## Thinking` and `## Diffs` to improve PERFORMANCE. Follow the guidance from Memory.


  include_all_history: false

# 任务特定配置（由 EffiBenchRunner 解释）
task_config:
  target: "integral"           # 可选: runtime | memory | integral
  code_generation_mode: "direct" # 可选: diff | direct
  enable_memory_checks: true
  enable_runtime_checks: true
  include_other_metrics_in_summary: true
  language: "python3"
  time_limit: 10       # 每次评估的时间限制（秒）
  memory_limit: 1024   # 内存限制（MB）
  max_workers: 5       # 并发测试的最大工作线程数
  num_runs: 5          # 性能测试运行次数
  trim_ratio: 0.1      # 剪裁比例，用于稳健均值
